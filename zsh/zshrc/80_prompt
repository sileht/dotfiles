# zshrc/80_prompt
#
# Formats the shell prompt
#
# Copyright © 1994–2008 martin f. krafft <madduck@madduck.net>
# Copyright Abaakouk Mehdi <sileht@sileht.net>
# Released under the terms of the Artistic Licence 2.0

eval $(keychain --eval --agents ssh --nogui --inherit any-once id_rsa ~/.ssh/id_dsa_h1)

setopt prompt_subst
autoload -Uz vcs_info
# set some colors
for COLOR in RED GREEN YELLOW WHITE BLACK CYAN GREY BLUE; do
    eval PR_$COLOR='%{$fg_no_bold[${(L)COLOR}]%}'         
    eval PR_BRIGHT_$COLOR='%{$fg_bold[${(L)COLOR}]%}'
done                                                 
PR_RESET="${reset_color}"

typeset -A color_hosts
set -A color_hosts \
    'bob' $PR_GREEN \
    'billy' $PR_CYAN \
    'ester' $PR_YELLOW \


# set formats
# %b - branchname
# %u - unstagedstr (see below)
# %c - stangedstr (see below)
# %a - action (e.g. rebase-i)
# %R - repository path
# %S - path in the repository

FMT_TYPE="${PR_WHITE}%s/"
FMT_BRANCH="${PR_GREEN}%b%u%c${PR_RESET}" # e.g. master¹²
FMT_ACTION="/(${PR_CYAN}%a${PR_RESET}%)"  # e.g. (rebase-i)

# check-for-changes can be really slow.
# you should disable it, if you work with large repositories    
zstyle ':vcs_info:*:prompt:*' check-for-changes true
zstyle ':vcs_info:*:prompt:*' unstagedstr '¹'  # display ¹ if there are unstaged changes
zstyle ':vcs_info:*:prompt:*' stagedstr '²'    # display ² if there are staged changes
zstyle ':vcs_info:*:prompt:*' actionformats " ${FMT_TYPE}${FMT_BRANCH}${FMT_ACTION}"
zstyle ':vcs_info:*:prompt:*' formats       " ${FMT_TYPE}${FMT_BRANCH}"

color_host_normal="$color_hosts[$(hostname -s)]"
color_host_normal="${color_host_normal:=$PR_BLUE}"
color_user_normal=$color_host_normal

function title {
	if [[ $TERM = screen* ]]; then 
		#In screen this is %w
		print -nR $'\033k'$1$'\033'\\ 
	fi 
	#In screen this is %h
    if [[ $TERM != linux ]]; then
    	print -nR $'\033]0;'$2$'\007'
    else
        print -nR $'\033]0;'$1' - '$2$'\007'
    fi
}

path_cut_offset=15
prompt_precmd () {
    local prompt_line_1a prompt_line_1b prompt_line_2 prompt_padding rprompt_line_2 color_user color_host
    color_user=$color_user_normal
    color_host=$color_host_normal
    [[ $USER = "root" ]] && color_user=$PR_BRIGHT_RED color_host=$PR_BRIGHT_RED

    local user="${color_user}$USER" 
    local host="${color_host}$(hostname)"
    local coma="${PR_BRIGHT_RED}:"
    local at="${PR_BRIGHT_RED}@"
    local rpath="${PR_BRIGHT_BLUE}%~"
    local opensep="${PR_BRIGHT_GREY}["
    local closesep="${PR_BRIGHT_GREY}]"
    local dollar="%(?,${PR_BRIGHT_GREEN},${PR_BRIGHT_RED})$"
    local return_code="${PR_BRIGHT_WHITE}?:%(?,${PR_BRIGHT_WHITE},${PR_BRIGHT_RED})%?"
    local njob="${PR_BRIGHT_WHITE}j:%j"

    prompt_line_1a="${opensep}${user}${at}${host}${coma} ${rpath}${closesep}"
    [ -n "$vcs_info_msg_0_" ] && vcs_info_msg=" ${vcs_info_msg_0_}" || vcs_info_msg=
    prompt_line_2="${opensep}${njob} ${return_code}${vcs_info_msg}${closesep} ${dollar} ${PR_RESET}"
    rprompt_line_2=""

    local prompt_line_1a_width=${#${(S%%)prompt_line_1a//\%\{*\%\}}}
    local prompt_line_1b_width=${#${(S%%)prompt_line_1b//\%\{*\%\}}}
    local prompt_padding_size=$(( COLUMNS - prompt_line_1a_width - prompt_line_1b_width ))
    eval "prompt_padding=\${(l:${prompt_padding_size}::${prompt_gfx_hyphen}:)_empty_zz}"
    export PS1=$'\n'$prompt_line_1a$prompt_padding$prompt_line_1b$'\n'$prompt_line_2
    export RPS1=$rprompt_line_2

    local pwd=${PWD/$HOME/"~"}
    [ ${#pwd} -gt $path_cut_offset ] && pwd="..."$pwd[${#pwd}-$path_cut_offset,${#pwd}]
    win_title="["${PWD/$HOME/"~"}"]"
    title "$pwd" "$win_title"
}

prompt_preexec () {
        emulate -L zsh
        local -a cmd
        cmd=(${(z)1})
        if [ "$cmd[1]" = "fg" ]; then 
            cmd=($(jobs | grep -v "continued" | sed 's,.*suspended *,,g' | head -n1 ))
        fi
        arg=$cmd[2,-1]
        if [ ${#arg} -gt $path_cut_offset ]
        then
                arg=" ..."$arg[${#arg}-$path_cut_offset,${#arg}]
        else
                arg=" "$arg
        fi
        print -nR "${PR_RESET}"
        win_title="["$(pwd)"] "$cmd[1,-1]
        title "$cmd[1]$arg" "$win_title"
        if [ "$cmd[1]" = "scr" -o "$cmd[1]" = "sr" -o "$cmd[1]" = "sn" ]; then
            print -nR "${PR_RESET}"
            title "$cmd[1]$arg" "Other"
        fi
}
export SPROMPT="${PR_RESET}""zsh: corriger ${PR_BRIGHT_GREEN}"%R"${PR_RESET} en ${PR_BRIGHT_GREEN}"%r"${PR_RESET} ? (yNea)"

function vcsinfo_precmd { vcs_info 'prompt'; }
precmd_functions+=vcsinfo_precmd
precmd_functions+=prompt_precmd
preexec_functions+=prompt_preexec

# vim:ft=zsh
