#!/bin/env python


import string
import subprocess
import sys
import threading

import gi

OFFSET_X = 20
OFFSET_Y = 50

LAPTOP_ICON = ""
DESKTOP_ICON = ""

OFF_COMMAND = "--output {} --off"
ON_COMMAND = "--output {} --auto --above {}"


def all_monitors_on():
    from Xlib import display

    d = display.Display()
    scr = d.screen()
    res = scr.root.xrandr_get_screen_resources()
    primary_output = scr.root.xrandr_get_output_primary().output
    output_to_attach_to = d.xrandr_get_output_info(primary_output, res.config_timestamp)
    commands = set()
    for output in res.outputs:
        info = d.xrandr_get_output_info(output, res.config_timestamp)
        print(f"{info.name}: {info.connection}")
        if output != primary_output and not info.connection:
            commands.add(ON_COMMAND.format(info.name, output_to_attach_to.name))
            output_to_attach_to = info

    if commands:
        cmd = f"xrandr {' '.join(commands)}"
        print(f"Run: {cmd}")
        subprocess.run(cmd, shell=True)


all_monitors_on()

gi.require_version("GLib", "2.0")
from gi.repository import GLib

gi.require_version("Gdk", "3.0")
from gi.repository import Gdk

gi.require_version("Gtk", "3.0")
from gi.repository import Gtk


class Layout:
    @classmethod
    @property
    def positions(cls):
        fmt = string.Formatter()
        return list(
            dict.fromkeys([v[1] for v in fmt.parse(cls.command) if v[1] is not None])
        )


class OneScreenLayout(Layout):
    label = ""
    command = "xrandr --output {primary} --auto --primary"


class VerticalLayout(Layout):
    label = "  "
    command = "xrandr --output {primary} --auto --primary --output {bottom} --auto --below {primary}"


class OnLeftLayout(Layout):
    label = "  "
    command = "xrandr --output {primary} --auto --primary --output {left} --auto --left-of {primary}"


class OnRightLayout(Layout):
    label = "  "
    command = "xrandr --output {primary} --auto --primary --output {right} --auto --right-of {primary}"


class BothSideLayout(Layout):
    label = "    "
    command = "xrandr --output {primary} --auto --primary --output {left} --auto --left-of {primary} --output {right} --auto --right-of {primary}"


LAYOUTS = (OneScreenLayout, VerticalLayout, OnLeftLayout, OnRightLayout, BothSideLayout)


def get_selection(title, options):
    if len(options) == 1:
        return list(options.items())[0]

    p = subprocess.Popen(
        [
            "rofi",
            "-font",
            "Noto Sans Symbolas2 24",
            "-dmenu",
            "-markup-rows",
            "-window-title",
            title,
        ],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        text=True,
    )
    selected = p.communicate(input="\n".join(options.keys()))[0][:-1]
    return selected, options.get(selected)


def menu(monitors):
    layouts = {}
    for l in LAYOUTS:
        print(f"Layout: {l.label}: {l.positions}")
        if len(l.positions) <= len(monitors):
            layouts[l.label] = l

    layout_label, layout = get_selection("Layout", layouts)
    if not layout:
        return

    print(f"Selected layout: {layout_label}: {'/'.join(layout.positions)}")

    selected_monitors = {}
    for position in layout.positions:
        selected_monitor_label, selected_monitor = get_selection(position, monitors)
        print(f"Selected {position}: {selected_monitor_label}: {selected_monitor}")
        if not selected_monitor:
            return
        selected_monitors[position] = selected_monitor
        del monitors[selected_monitor_label]

    cmd = layout.command.format(**selected_monitors)

    for v in monitors.values():
        cmd += " %s" % OFF_COMMAND.format(v)

    print(f"cmd: {cmd}")
    result = subprocess.run(
        cmd, shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, text=True
    )
    if result.stdout:
        print(f"FAIL: {result.stdout}")
        subprocess.run(
            [
                "notify-send",
                "-i",
                "/usr/share/icons/Humanity-Dark/apps/24/gsd-xrandr.svg",
                "display configuration error",
                f"selected: {l.label}\nran: {cmd}\nresult:{result.stdout}",
            ]
        )
    else:
        config = subprocess.run(
            "xrandr --listactivemonitors",
            shell=True,
            stdout=subprocess.PIPE,
            text=True,
        ).stdout
        subprocess.run(
            [
                "notify-send",
                "-i",
                "/usr/share/icons/Humanity-Dark/apps/24/gsd-xrandr.svg",
                "display configuration done",
                f"selected: {l.label}\nran: {cmd}\n{config}",
            ]
        )


def main():
    windows = []
    monitors = {}

    disp = Gdk.Display.get_default()
    for n in range(disp.get_n_monitors()):
        mon = disp.get_monitor(n)
        geo = mon.get_geometry()

        # print(disp.get_default_seat())
        print(
            f"{mon.get_manufacturer()} / {mon.get_model()}: {geo.width}x{geo.height}+{geo.x}+{geo.y}"
        )

        l = Gtk.Label()
        l.set_markup(f"<b>{mon.get_manufacturer()}</b>\n{mon.get_model()}")

        w = Gtk.Window(type=Gtk.WindowType.POPUP)
        w.add(l)
        w.set_modal(True)
        w.resize(250, 100)
        w.move(geo.x + OFFSET_X, geo.y + OFFSET_Y)
        w.show_all()

        icon = LAPTOP_ICON if mon.get_model().startswith("eDP") else DESKTOP_ICON
        monitors[
            f"{icon} {mon.get_model()}: {mon.get_manufacturer()}"
        ] = mon.get_model()
        windows.append(w)

    t = threading.Thread(target=menu, args=(monitors,))
    t.daemon = True
    t.start()

    def wait_menu_exit():
        if not t.is_alive():
            Gtk.main_quit()
        return True

    GLib.idle_add(wait_menu_exit)


main()
Gtk.main()
sys.exit(0)
