#!/bin/env python

import json
import time
import struct
from collections import namedtuple
import argparse
import string
import logging
import subprocess
import threading

import gi

gi.require_version("GLib", "2.0")
gi.require_version("Gdk", "3.0")
gi.require_version("Gtk", "3.0")

import Xlib.display
import Xlib.error

logging.basicConfig(level=logging.DEBUG)

OFFSET_X = 20
OFFSET_Y = 50

LAPTOP_ICON = ""
DESKTOP_ICON = ""

OFF_COMMAND = "--output {} --off"
ON_COMMAND = "--output {} --auto --above {}"

with open("/usr/share/hwdata/pnp.ids") as f:
    PNP_MAPS = {}
    for line in f.readlines():
        pnp_id, _, vendor = line.strip().partition("\t")
        PNP_MAPS[pnp_id] = vendor


def get_vendor(pnp_id):
    return f"{PNP_MAPS.get(pnp_id, pnp_id)} ({pnp_id})"


RawEdid = namedtuple(
    "RawEdid",
    (
        "header",
        "manu_id",
        "prod_id",
        "serial_no",
        "manu_week",
        "manu_year",
        "edid_version",
        "edid_revision",
        "input_type",
        "width",
        "height",
        "gamma",
        "features",
        "color",
        "timings_supported",
        "timings_reserved",
        "timings_edid",
        "timing_1",
        "timing_2",
        "timing_3",
        "timing_4",
        "extension",
        "checksum",
    ),
)
EDID_STRUCT_FORMAT = (
    ">"  # big-endian
    "8s"  # constant header (8 bytes)
    "H"  # manufacturer id (2 bytes)
    "H"  # product id (2 bytes)
    "I"  # serial number (4 bytes)
    "B"  # manufactoring week (1 byte)
    "B"  # manufactoring year (1 byte)
    "B"  # edid version (1 byte)
    "B"  # edid revision (1 byte)
    "B"  # video input type (1 byte)
    "B"  # horizontal size in cm (1 byte)
    "B"  # vertical size in cm (1 byte)
    "B"  # display gamma (1 byte)
    "B"  # supported features (1 byte)
    "10s"  # color characteristics (10 bytes)
    "H"  # supported timings (2 bytes)
    "B"  # reserved timing (1 byte)
    "16s"  # EDID supported timings (16 bytes)
    "18s"  # detailed timing block 1 (18 bytes)
    "18s"  # detailed timing block 2 (18 bytes)
    "18s"  # detailed timing block 3 (18 bytes)
    "18s"  # detailed timing block 4 (18 bytes)
    "B"  # extension flag (1 byte)
    "B"
)  # checksum (1 byte)


def model_from_edid(output="DP-1"):
    with open(f"/sys/class/drm/card0-{output}/edid", "rb") as f:
        blob = f.read()[:128]

        if sum(map(int, blob)) % 256 != 0:
            logging.warning("EDID: checksum error.")
            return ""
        if struct.calcsize(EDID_STRUCT_FORMAT) != 128:
            logging.warning("EDID: wrong size.")
            return ""

        unpacked = struct.unpack(EDID_STRUCT_FORMAT, blob)
        raw_edid = RawEdid(*unpacked)

        if raw_edid.header != b"\x00\xff\xff\xff\xff\xff\xff\x00":
            logging.error("EDID: Invalid header.")

        for timing_bytes in (
            raw_edid.timing_1,
            raw_edid.timing_2,
            raw_edid.timing_3,
            raw_edid.timing_4,
        ):
            # "other" descriptor
            if timing_bytes[0:2] == b"\x00\x00":
                timing_type = timing_bytes[3]
                # https://en.wikipedia.org/wiki/Extended_Display_Identification_Data#Display_Descriptors
                if timing_type == 0xFC:
                    buffer = timing_bytes[5:]
                    buffer = buffer.partition(b"\x0a")[0]
                    text = buffer.decode("cp437")
                    return text
        return ""


def wakeup_all_monitors(dry_run):
    d = Xlib.display.Display()
    scr = d.screen()
    res = scr.root.xrandr_get_screen_resources()

    outputs_off = []
    outputs_on = []
    outputs_on_to_switch_off = []
    for output in reversed(res.outputs):
        info = d.xrandr_get_output_info(output, res.config_timestamp)
        resolution = "....x...."
        if info.crtc:
            crtc = d.xrandr_get_crtc_info(info.crtc, res.config_timestamp)
            resolution = f"{crtc.width}x{crtc.height}"
        have_output_connected = info.connection == 0
        have_output_on = bool(info.crtc)
        logging.info(
            f"{info.name}: have_output_on={have_output_on} have_output_connected={have_output_connected} resolution={resolution}"
        )
        if have_output_connected and not have_output_on:
            outputs_off.append(info.name)
        elif have_output_on and not have_output_connected:
            outputs_on_to_switch_off.append(info.name)
        else:
            outputs_on.append(info.name)

    primary_output = scr.root.xrandr_get_output_primary().output
    try:
        output_to_attach_to = d.xrandr_get_output_info(
            primary_output, res.config_timestamp
        ).name
    except Xlib.error.XError:
        output_to_attach_to = outputs_on[0]

    logging.info(f"current primary: {output_to_attach_to}")

    commands = set()
    for output in outputs_off:
        commands.add(ON_COMMAND.format(output, output_to_attach_to))
        output_to_attach_to = info.name

    for output in outputs_on_to_switch_off:
        commands.add(OFF_COMMAND.format(output))

    if commands:
        cmd = f"xrandr {' '.join(commands)}"
        logging.info(f"Run: {cmd}")
        if dry_run:
            return
        subprocess.run(cmd, shell=True)


class Layout:
    predefined = {}

    @classmethod
    @property
    def positions(cls):
        fmt = string.Formatter()
        return list(
            dict.fromkeys([v[1] for v in fmt.parse(cls.command) if v[1] is not None])
        )


class OneScreenLayout(Layout):
    label = ""
    command = "xrandr --output {primary} --auto --primary"


class OnAutoRightLayout(Layout):
    label = "   (auto)"
    command = "xrandr --output {primary} --auto --primary --output {right} --auto --right-of {primary}"
    predefined = {"right": "eDP-1"}


class VerticalLayout(Layout):
    label = "  "
    command = "xrandr --output {primary} --auto --primary --output {bottom} --auto --below {primary}"


class OnLeftLayout(Layout):
    label = "  "
    command = "xrandr --output {primary} --auto --primary --output {left} --auto --left-of {primary}"


class OnRightLayout(Layout):
    label = "  "
    command = "xrandr --output {primary} --auto --primary --output {right} --auto --right-of {primary}"


class BothSideLayout(Layout):
    label = "    "
    command = "xrandr --output {primary} --auto --primary --output {left} --auto --left-of {primary} --output {right} --auto --right-of {primary}"


LAYOUTS = (
    OnAutoRightLayout,
    OneScreenLayout,
    VerticalLayout,
    OnLeftLayout,
    OnRightLayout,
    BothSideLayout,
)


def get_selection(title, options):
    if len(options) == 1:
        return list(options.items())[0]

    p = subprocess.Popen(
        [
            "rofi",
            "-font",
            "Noto Sans Symbolas2 24",
            "-dmenu",
            "-markup-rows",
            "-window-title",
            title,
        ],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        text=True,
    )
    selected = p.communicate(input="\n".join(options.keys()))[0][:-1]
    return selected, options.get(selected)


def wait_become_primary(name):
    from gi.repository import Gdk
    disp = Gdk.Display.get_default()

    while range(0, 20):
        for n in range(disp.get_n_monitors()):
            mon = disp.get_monitor(n)
            output = mon.get_model()
            if output == name:
                if mon.is_primary():
                    print(f"{name} is primary")
                    return
                else:
                    break
        else:
            print(f"can wait for {name}: not found")
        time.sleep(0.5)
    print(f"{name} never become primary")


def show_menu(dry_run):
    from gi.repository import Gdk

    monitors = {}
    disp = Gdk.Display.get_default()

    for n in range(disp.get_n_monitors()):
        mon = disp.get_monitor(n)
        output = mon.get_model()
        icon = LAPTOP_ICON if output.startswith("eDP") else DESKTOP_ICON
        vendor_id = mon.get_manufacturer()
        vendor = get_vendor(vendor_id)
        model = model_from_edid(output)
        logging.info(f"{vendor_id} {model}")
        monitors[f"{icon} {output}: {vendor} | {model}"] = output

    layouts = {}
    for layout in LAYOUTS:
        logging.info(f"Layout: {layout.label}: {layout.positions}")
        if len(layout.positions) <= len(monitors):
            layouts[layout.label] = layout

    layout_label, layout = get_selection("Layout", layouts)
    if not layout:
        return

    logging.info(f"Selected layout: {layout_label}: {'/'.join(layout.positions)}")

    selected_monitors = {}
    for position in sorted(layout.positions, key=lambda p: p not in layout.predefined):
        predefined_m_id = layout.predefined.get(position)
        selected_monitor_label, selected_monitor = get_selection(
            position,
            {
                m_label: m_id
                for m_label, m_id in monitors.items()
                if predefined_m_id is None or m_id == predefined_m_id
            },
        )
        logging.info(
            f"Selected {position}: {selected_monitor_label}: {selected_monitor}"
        )
        if not selected_monitor:
            return
        selected_monitors[position] = selected_monitor
        del monitors[selected_monitor_label]

    cmd = layout.command.format(**selected_monitors)

    for v in monitors.values():
        cmd += " %s" % OFF_COMMAND.format(v)

    logging.info(f"cmd: {cmd}")
    if dry_run:
        return

    result = subprocess.run(
        cmd, shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, text=True
    )
    if result.stdout:
        logging.info(f"FAIL: {result.stdout}")
        subprocess.run(
            [
                "notify-send",
                "-i",
                "/usr/share/icons/Humanity-Dark/apps/24/gsd-xrandr.svg",
                "display configuration error",
                f"selected: {l.label}\nran: {cmd}\nresult:{result.stdout}",
            ]
        )
    else:
        config = subprocess.run(
            "xrandr --listactivemonitors",
            shell=True,
            stdout=subprocess.PIPE,
            text=True,
        ).stdout
        subprocess.run(
            [
                "notify-send",
                "-i",
                "/usr/share/icons/Humanity-Dark/apps/24/gsd-xrandr.svg",
                "display configuration done",
                f"selected: {layout.label}\nran: {cmd}\n{config}",
            ]
        )

        wait_become_primary(selected_monitors["primary"])
        time.sleep(1)
        output = subprocess.check_output("i3-msg -t get_workspaces", shell=True)
        i3config = json.loads(output)
        workspace_to_move = [
            workspace["num"] for workspace in i3config
            if workspace["output"] != selected_monitors["primary"]
        ]
        commands = []
        for i in workspace_to_move:
            commands.extend([
                f"i3-msg workspace {i}",
                "i3-msg move workspace to output primary"
            ])
        commands += [
            "/home/sileht/.env/bin/polybar-start.sh",
            "unsplash",
            "i3-msg workspace 1",
        ]
        for command in commands:
            print(command)
            subprocess.Popen(command, shell=True, start_new_session=True)


def show_screen_name_popups():
    from gi.repository import Gdk, Gtk

    disp = Gdk.Display.get_default()
    for n in range(disp.get_n_monitors()):
        mon = disp.get_monitor(n)
        geo = mon.get_geometry()

        output = mon.get_model()
        vendor = get_vendor(mon.get_manufacturer())
        model = model_from_edid(output)
        logging.info(f"{vendor} / {output}: {geo.width}x{geo.height}+{geo.x}+{geo.y}")

        label = Gtk.Label()
        label.set_markup(f"<b>{vendor}\n{model}</b>\n{output}")

        w = Gtk.Window(type=Gtk.WindowType.POPUP)
        w.add(label)
        w.set_modal(True)
        w.resize(250, 100)
        w.move(geo.x + OFFSET_X, geo.y + OFFSET_Y)
        w.show_all()


def main():
    parser = argparse.ArgumentParser(description="Screen selector")
    parser.add_argument("--dry-run", action="store_true")
    args = parser.parse_args()

    wakeup_all_monitors(args.dry_run)

    show_screen_name_popups()

    t = threading.Thread(target=show_menu, args=(args.dry_run,))
    t.daemon = True
    t.start()

    from gi.repository import GLib, Gtk

    def wait_menu_exit():
        if not t.is_alive():
            Gtk.main_quit()
        return True

    GLib.idle_add(wait_menu_exit)
    Gtk.main()


if __name__ == "__main__":
    main()
