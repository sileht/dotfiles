#!/bin/env python

import argparse
import dataclasses
import json
import logging
import string
import struct
import subprocess
import threading
import time
import typing
from collections import namedtuple

import gi
import Xlib.display
import Xlib.error

gi.require_version("GLib", "2.0")
gi.require_version("Gdk", "3.0")
gi.require_version("Gtk", "3.0")

from gi.repository import Gdk, GLib, Gtk  # noqa

logging.basicConfig(level=logging.DEBUG)

OFFSET_X = 20
OFFSET_Y = 50

LAPTOP_ICON = "ï„‰"
DESKTOP_ICON = "ï¡¸"

OFF_COMMAND = "--output {} --off"
ON_COMMAND = "--output {} --auto --above {}"

with open("/usr/share/hwdata/pnp.ids") as f:
    PNP_MAPS = {}
    for line in f.readlines():
        pnp_id, _, vendor = line.strip().partition("\t")
        PNP_MAPS[pnp_id] = vendor


def get_vendor(pnp_id):
    return f"{PNP_MAPS.get(pnp_id, pnp_id)} ({pnp_id})"


RawEdid = namedtuple(
    "RawEdid",
    (
        "header",
        "manu_id",
        "prod_id",
        "serial_no",
        "manu_week",
        "manu_year",
        "edid_version",
        "edid_revision",
        "input_type",
        "width",
        "height",
        "gamma",
        "features",
        "color",
        "timings_supported",
        "timings_reserved",
        "timings_edid",
        "timing_1",
        "timing_2",
        "timing_3",
        "timing_4",
        "extension",
        "checksum",
    ),
)
EDID_STRUCT_FORMAT = (
    ">"  # big-endian
    "8s"  # constant header (8 bytes)
    "H"  # manufacturer id (2 bytes)
    "H"  # product id (2 bytes)
    "I"  # serial number (4 bytes)
    "B"  # manufactoring week (1 byte)
    "B"  # manufactoring year (1 byte)
    "B"  # edid version (1 byte)
    "B"  # edid revision (1 byte)
    "B"  # video input type (1 byte)
    "B"  # horizontal size in cm (1 byte)
    "B"  # vertical size in cm (1 byte)
    "B"  # display gamma (1 byte)
    "B"  # supported features (1 byte)
    "10s"  # color characteristics (10 bytes)
    "H"  # supported timings (2 bytes)
    "B"  # reserved timing (1 byte)
    "16s"  # EDID supported timings (16 bytes)
    "18s"  # detailed timing block 1 (18 bytes)
    "18s"  # detailed timing block 2 (18 bytes)
    "18s"  # detailed timing block 3 (18 bytes)
    "18s"  # detailed timing block 4 (18 bytes)
    "B"  # extension flag (1 byte)
    "B"
)  # checksum (1 byte)


def parse_edid(output="DP-1"):
    with open(f"/sys/class/drm/card0-{output}/edid", "rb") as f:
        blob = f.read()[:128]

        if sum(map(int, blob)) % 256 != 0:
            logging.warning("EDID: checksum error.")
            return "", ""
        if struct.calcsize(EDID_STRUCT_FORMAT) != 128:
            logging.warning("EDID: wrong size.")
            return "", ""

        unpacked = struct.unpack(EDID_STRUCT_FORMAT, blob)
        raw_edid = RawEdid(*unpacked)
        c1 = chr(((raw_edid.manu_id >> 10) & 0x1F) + 64)
        c2 = chr(((raw_edid.manu_id >> 5) & 0x1F) + 64)
        c3 = chr((raw_edid.manu_id & 0x1F) + 64)
        manu = f"{c1}{c2}{c3}"

        if raw_edid.header != b"\x00\xff\xff\xff\xff\xff\xff\x00":
            logging.error("EDID: Invalid header.")

        for timing_bytes in (
            raw_edid.timing_1,
            raw_edid.timing_2,
            raw_edid.timing_3,
            raw_edid.timing_4,
        ):
            # "other" descriptor
            if timing_bytes[0:2] == b"\x00\x00":
                timing_type = timing_bytes[3]
                # https://en.wikipedia.org/wiki/Extended_Display_Identification_Data#Display_Descriptors
                if timing_type == 0xFC:
                    buffer = timing_bytes[5:]
                    buffer = buffer.partition(b"\x0a")[0]
                    text = buffer.decode("cp437")
                    return manu, text
        return manu, ""


@dataclasses.dataclass
class MonitorSpec:
    width: int
    height: int
    x: int
    y: int


@dataclasses.dataclass
class Output:
    name: str
    icon: str
    switched_on: str
    primary: bool
    monitor_vendor_id: str
    monitor_vendor: str
    monitor_model: str
    monitor_spec: typing.Optional[MonitorSpec]


def get_outputs() -> typing.List[Output]:
    d = Xlib.display.Display()
    scr = d.screen()
    res = scr.root.xrandr_get_screen_resources()
    primary = scr.root.xrandr_get_output_primary()

    outputs = []
    for output in reversed(res.outputs):
        info = d.xrandr_get_output_info(output, res.config_timestamp)

        if info.connection != 0:
            continue

        spec = None
        if info.crtc:
            crtc = d.xrandr_get_crtc_info(info.crtc, res.config_timestamp)
            spec = MonitorSpec(crtc.width, crtc.height, crtc.x, crtc.y)

        vendor_id, model = parse_edid(info.name)
        outputs.append(
            Output(
                name=info.name,
                icon=LAPTOP_ICON if info.name.startswith("eDP") else DESKTOP_ICON,
                switched_on=bool(info.crtc),
                primary=primary.output == output,
                monitor_vendor_id=vendor_id,
                monitor_vendor=get_vendor(vendor_id),
                monitor_model=model,
                monitor_spec=spec,
            )
        )
    return outputs


def show_screen_name_popups(outputs):
    for output in outputs:
        if not output.switched_on:
            continue

        label = Gtk.Label()
        label.set_markup(
            f"<b>{output.monitor_vendor}\n{output.monitor_model}</b>\n{output.name}"
        )

        w = Gtk.Window(type=Gtk.WindowType.POPUP)
        w.add(label)
        w.set_modal(True)
        w.resize(250, 100)
        w.move(output.monitor_spec.x + OFFSET_X, output.monitor_spec.y + OFFSET_Y)
        w.show_all()


class Layout:
    predefined = {}

    @classmethod
    @property
    def positions(cls):
        fmt = string.Formatter()
        return list(
            dict.fromkeys([v[1] for v in fmt.parse(cls.command) if v[1] is not None])
        )

    @classmethod
    def match(cls, monitors):
        positions = monitors.keys()
        if set(cls.positions) == set(positions):
            for pos, name in cls.predefined.items():
                if monitors[pos].name != name:
                    return False
            return True

        return False


class OneScreenLayout(Layout):
    label = "ï¡¸"
    command = "xrandr --output {primary} --auto --primary"


class OnAutoRightLayout(Layout):
    label = "ï¡¸ ï‚© ï„‰ (auto)"
    command = (
        "xrandr --output {primary} --auto --primary "
        "--output {right} --auto --right-of {primary}"
    )
    predefined = {"right": "eDP-1"}


class OnAutoBottomLayout(Layout):
    label = "ï¡¸ ï‚« ï„‰ (auto)"
    command = (
        "xrandr --output {primary} --auto --primary "
        "--output {bottom} --auto --below {primary}"
    )
    predefined = {"bottom": "eDP-1"}


class OnAutoOneScreenLayout(Layout):
    label = "ï¡¸ (eDP-1)"
    command = "xrandr --output {primary} --auto --primary"
    predefined = {"primary": "eDP-1"}


class VerticalLayout(Layout):
    label = "ï¡¸ ï‚« ï„‰"
    command = (
        "xrandr --output {primary} --auto --primary "
        "--output {bottom} --auto --below {primary}"
    )


class OnLeftLayout(Layout):
    label = "ï„‰ ï‚¨ ï¡¸"
    command = (
        "xrandr --output {primary} --auto --primary "
        "--output {left} --auto --left-of {primary}"
    )


class OnRightLayout(Layout):
    label = "ï¡¸ ï‚© ï„‰"
    command = (
        "xrandr --output {primary} --auto --primary "
        "--output {right} --auto --right-of {primary}"
    )


class BothSideLayout(Layout):
    label = "ï„‰ ï‚¨ ï¡¸ ï‚© ï¡¸"
    command = (
        "xrandr --output {primary} --auto --primary "
        "--output {left} --auto --left-of {primary} "
        "--output {right} --auto --right-of {primary}"
    )


LAYOUTS = (
    OnAutoRightLayout,
    OnAutoBottomLayout,
    OnAutoOneScreenLayout,
    OneScreenLayout,
    VerticalLayout,
    OnLeftLayout,
    OnRightLayout,
    BothSideLayout,
)


def get_selection(title, options, option_to_ignore=0):
    if len(options) == 1 + option_to_ignore:
        return list(options.items())[0]

    p = subprocess.Popen(
        [
            "rofi",
            "-font",
            "Noto Sans Symbolas2 24",
            "-dmenu",
            "-markup-rows",
            "-window-title",
            title,
        ],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        text=True,
    )
    selected = p.communicate(input="\n".join(options.keys()))[0][:-1]
    return selected, options.get(selected)


def get_curent_layout(outputs):
    primary = [o for o in outputs if o.primary]
    if not primary:
        return
    primary = primary[0]
    monitors = {"primary": primary}
    for o in outputs:
        if not o.switched_on or o.primary:
            continue

        if o.monitor_spec.x > primary.monitor_spec.x:
            monitors["right"] = o
        elif o.monitor_spec.x < primary.monitor_spec.x:
            monitors["left"] = o
        elif (
            o.monitor_spec.x == primary.monitor_spec.x
            and o.monitor_spec.y > primary.monitor_spec.y
        ):
            monitors["bottom"] = o
        elif (
            o.monitor_spec.x == primary.monitor_spec.x
            and o.monitor_spec.y < primary.monitor_spec.y
        ):
            monitors["top"] = o

    for layout in LAYOUTS:
        if layout.match(monitors):
            return layout


def wakeup_all_monitors(outputs, dry_run):
    output_to_attach_to = [o for o in outputs if o.primary][0].name
    logging.info(f"current primary: {output_to_attach_to}")

    outputs_off = [o for o in outputs if not o.switched_on]
    commands = set()
    for output in outputs_off:
        commands.add(ON_COMMAND.format(output.name, output_to_attach_to))
        output_to_attach_to = output.name

    # for output in outputs_on_to_switch_off:
    #    commands.add(OFF_COMMAND.format(output))

    if commands:
        cmd = f"xrandr {' '.join(commands)}"
        logging.info(f"Run: {cmd}")
        if dry_run:
            return
        subprocess.run(cmd, shell=True)


def wait_become_primary(name):
    while range(0, 20):
        for output in get_outputs():
            if output.name == name:
                if output.primary:
                    print(f"{name} is primary")
                    return
                else:
                    break
        else:
            print(f"can wait for {name}: not found")
        time.sleep(0.5)
    print(f"{name} never become primary")


def show_menu(outputs, current_layout, dry_run):
    monitors = {}

    for o in outputs:
        monitors[f"{o.icon} {o.name}: {o.monitor_vendor} | {o.monitor_model}"] = o.name

    layouts = {}
    for layout in LAYOUTS:
        logging.info(f"Layout: {layout.label}: {layout.positions}")
        if len(layout.positions) <= len(monitors) and layout != current_layout:
            layouts[layout.label] = layout

    layouts["ðŸ’¤ wakeup all monitors"] = "wakeup"

    layout_label, layout = get_selection("Layout", layouts, option_to_ignore=1)
    if not layout:
        return

    print(layout)
    if layout == "wakeup":
        subprocess.run(
            [__file__, "--wakeup"],
            start_new_session=True,
        )
        return

    logging.info(f"Selected layout: {layout_label}: {'/'.join(layout.positions)}")

    selected_monitors = {}
    for position in sorted(layout.positions, key=lambda p: p not in layout.predefined):
        predefined_m_id = layout.predefined.get(position)
        selected_monitor_label, selected_monitor = get_selection(
            position,
            {
                m_label: m_id
                for m_label, m_id in monitors.items()
                if predefined_m_id is None or m_id == predefined_m_id
            },
        )
        logging.info(
            f"Selected {position}: {selected_monitor_label}: {selected_monitor}"
        )
        if not selected_monitor:
            return
        selected_monitors[position] = selected_monitor
        del monitors[selected_monitor_label]

    cmd = layout.command.format(**selected_monitors)

    for v in monitors.values():
        cmd += " %s" % OFF_COMMAND.format(v)

    logging.info(f"cmd: {cmd}")
    if dry_run:
        return

    result = subprocess.run(
        cmd, shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, text=True
    )
    if result.stdout:
        logging.info(f"FAIL: {result.stdout}")
        subprocess.run(
            [
                "notify-send",
                "-i",
                "/usr/share/icons/Humanity-Dark/apps/24/gsd-xrandr.svg",
                "display configuration error",
                f"ran: {cmd}\nresult:{result.stdout}",
            ]
        )
    else:
        config = subprocess.run(
            "xrandr --listactivemonitors",
            shell=True,
            stdout=subprocess.PIPE,
            text=True,
        ).stdout
        subprocess.run(
            [
                "notify-send",
                "-i",
                "/usr/share/icons/Humanity-Dark/apps/24/gsd-xrandr.svg",
                "display configuration done",
                f"selected: {layout.label}\nran: {cmd}\n{config}",
            ]
        )

        wait_become_primary(selected_monitors["primary"])
        time.sleep(1)
        output = subprocess.check_output("i3-msg -t get_workspaces", shell=True)
        i3config = json.loads(output)
        workspace_to_move = [
            workspace["num"]
            for workspace in i3config
            if workspace["output"] != selected_monitors["primary"]
        ]
        commands = []
        for i in workspace_to_move:
            commands.extend(
                [f"i3-msg workspace {i}", "i3-msg move workspace to output primary"]
            )
        commands += [
            "/home/sileht/.env/bin/polybar-start.sh",
            "unsplash",
            "i3-msg workspace 1",
        ]
        for command in commands:
            print(command)
            subprocess.Popen(command, shell=True, start_new_session=True)


def main():
    parser = argparse.ArgumentParser(description="Screen selector")
    parser.add_argument("--wakeup", action="store_true")
    parser.add_argument("--dry-run", action="store_true")
    args = parser.parse_args()

    outputs = get_outputs()
    if args.wakeup:
        wakeup_all_monitors(outputs, args.dry_run)
        outputs = get_outputs()

    current_layout = get_curent_layout(outputs)
    logging.info("Current layout: %s", str(current_layout))

    show_screen_name_popups(outputs)

    t = threading.Thread(target=show_menu, args=(outputs, current_layout, args.dry_run))
    t.daemon = True
    t.start()

    def wait_menu_exit():
        if not t.is_alive():
            Gtk.main_quit()
        return True

    GLib.idle_add(wait_menu_exit)
    Gtk.main()


if __name__ == "__main__":
    main()
