#!/usr/bin/python3
# -*- coding: utf-8 -*-
# flake8: noqa: E501
"""Sound controller."""

import fnmatch
import functools
import shlex
import subprocess
import time

import pulsectl


def _run(cmd, timeout=None):
    return subprocess.run(
        shlex.split(cmd), check=True, stdout=subprocess.PIPE, text=True, timeout=timeout
    ).stdout


def _is_bluetooth_on():
    for line in _run("bluetoothctl show").split("\n"):
        line = line.strip()
        if line == "Powered: yes":
            return True
    return False


def _select_input(pulse, card, profile):
    pulse.card_profile_set(card, profile.name)

    sources = []
    while not sources:
        time.sleep(0.1)
        sources = [
            source
            for source in pulse.source_list()
            if source.card == card.index
            or source.name == "auto_null"
            or profile.name == "off"
        ]

    source_output = sources[0]
    pulse.default_set(source_output)
    for source_input in pulse.sink_input_list():
        pulse.source_input_move(source_input.index, source_output.index)


def _select_output(pulse, card, profile):
    pulse.card_profile_set(card, profile.name)

    sinks = []
    while not sinks:
        time.sleep(0.1)
        sinks = [
            sink
            for sink in pulse.sink_list()
            if sink.card == card.index
            or sink.name == "auto_null"
            or profile.name == "off"
        ]

    sink_output = sinks[0]
    pulse.default_set(sink_output)
    for sink_input in pulse.sink_input_list():
        pulse.sink_input_move(sink_input.index, sink_output.index)


def _get_bluetooth_device_info(mac):
    info = {}
    for line in _run(f"bluetoothctl info {mac}").split("\n")[1:]:
        name, _, value = line.strip().partition(": ")
        if name == "UUID":
            value = value.split("(")[0].strip()
            info.setdefault(name, []).append(value)
        else:
            info[name] = value
    return info


def _bluetooth_scan():
    try:
        _run("bluetoothctl scan on", timeout=10)
    except subprocess.TimeoutExpired:
        pass


def _get_bluetooth_items():
    items = {}
    items["Scan (10 seconds) \0icon\x1fbluetooth-paired"] = _bluetooth_scan
    for line in _run("bluetoothctl devices").split("\n"):
        if not line.strip():
            continue
        mac, _, name = line.strip()[7:].partition(" ")
        info = _get_bluetooth_device_info(mac)
        name = info.get("Name", "Unknown")
        prefix = f"{name} / {mac} |"
        suffix = "\0icon\x1faudio-headphones"
        if info["Paired"] == "yes":
            connected = info["Connected"] == "yes"

            if "Audio Sink" in info["UUID"]:
                if connected:
                    items[f"<b>{prefix} Disconnect</b> {suffix}"] = f"bluetoothctl disconnect {mac}"
                else:
                    items[f"{prefix} Connect {suffix}"] = f"bluetoothctl connect {mac}"

            items[f"{prefix}Unpair{suffix}"] = f"bluetoothctl remove {mac}"
        else:
            items[f"{prefix}Pair{suffix}"] = [
                f"bluetoothctl trust {mac}",
                f"bluetoothctl pair {mac}",
                f"bluetoothctl connect {mac}",
            ]
    return items


HIDDEN_PROFILES = (
    "input:analog-stereo",  # We keep only the duplex
    "output:analog-stereo",  # We keep only the duplex
    "pro-audio",
    "*iec958*",
    "input:mono-fallback",
)


def _get_pulseaudio_cards_profiles(pulse, mode="sink"):
    if mode == "sink":
        default_name = pulse.server_info().default_sink_name
        default_index = [
            sink.card for sink in pulse.sink_list() if sink.name == default_name
        ][0]
    elif mode == "source":
        default_name = pulse.server_info().default_source_name
        default_index = [
            source.card for source in pulse.source_list() if source.name == default_name
        ][0]
    else:
        raise RuntimeError(f"wrong mode: {mode}")
    items = {}
    cards = pulse.card_list()
    for card in reversed(cards):
        for profile in reversed(card.profile_list):
            if not profile.available:
                continue
            if any(p for p in HIDDEN_PROFILES if fnmatch.fnmatch(profile.name, p)):
                continue
            if mode == "sink" and profile.n_sinks == 0:
                continue
            if mode == "source" and profile.n_sources == 0:
                continue

            # print(profile)
            selected = False
            if (
                card.index == default_index and profile.name == card.profile_active.name
            ) or (profile.name == "off" and default_name == "auto_null"):
                selected = True
            print(card.proplist)
            if card.proplist["device.api"].endswith("bluez5"):
                icon = "audio-headphones"
            elif mode == "sink":
                icon = "audio-speakers"
            elif mode == "source":
                icon = "audio-input-microphone"
            else:
                raise RuntimeError(f"wrong mode: {mode}")
            label = (
                f"{card.proplist['device.description']} | {profile.description}"
            )
            if selected:
                label = f"<b>{label}</b>"
            label += f"\0icon\x1f{icon}"
            if mode == "sink":
                items[label] = functools.partial(_select_output, pulse, card, profile)
            elif mode == "source":
                items[label] = functools.partial(_select_input, pulse, card, profile)
            else:
                raise RuntimeError(f"wrong mode: {mode}")
    return items


def main(pulse):
    items = {}
    items['<span underline="1">Audio Output</span>\0icon\x1faudio-output-none'] = "pavucontrol -t 3"
    items.update(_get_pulseaudio_cards_profiles(pulse, "sink"))
    items[" "] = ""
    items['<span underline="1">Audio Input</span>\0icon\x1faudio-input-microphone-none-panel'] = "pavucontrol -t 4"
    items.update(_get_pulseaudio_cards_profiles(pulse, "source"))
    items["  "] = ""
    if _is_bluetooth_on():
        items['<span underline="1">Bluetooth</span> - on\0icon\x1fbluetooth-active-symbolic'] = "bluetoothctl power off"
        items.update(_get_bluetooth_items())
    else:
        items['<span underline="1">Bluetooth</span> - off\0icon\x1fbluetooth-disabled-symbolic'] = "bluetoothctl power on"

    for pos, key in enumerate(items):
        if "<b>" in key:
            break
    else:
        pos = None

    if pos is not None:
        selection = ["-selected-row", str(pos)]
    else: 
        selection = []
    p = subprocess.Popen(
        ["rofi", "-dmenu", "-markup-rows"] + selection,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        text=True,
    )
    selected = p.communicate(input="\n".join(items.keys()))[0][:-1]
    if selected:
        items_without_icon = {k.split("\0")[0]: v  for k, v in items.items()}
        print(selected)
        callback = items_without_icon.get(selected)
        if callback:
            print(f"Ran: {callback}")
            if isinstance(callback, str):
                _run(callback)
            elif isinstance(callback, list):
                for c in callback:
                    _run(c)
            else:
                callback()
        else:
            print("Selected invalid")
    else:
        print("Nothing selected")


if __name__ == "__main__":
    with pulsectl.Pulse("sound-controller") as pulse:
        main(pulse)
