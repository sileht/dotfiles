#!/usr/bin/python3
# -*- coding: utf-8 -*-
# flake8: noqa: E501
"""Sound controller."""

import fnmatch
import functools
import shlex
import subprocess
import time

import pulsectl


def _run(cmd, timeout=None):
    return subprocess.run(
        shlex.split(cmd), check=True, stdout=subprocess.PIPE, text=True, timeout=timeout
    ).stdout


def _is_bluetooth_on():
    for line in _run("bluetoothctl show").split("\n"):
        line = line.strip()
        if line == "Powered: yes":
            return True
    return False

def _select_input(pulse, card, profile):
    pulse.card_profile_set(card, profile.name)

    sources = []
    while not sources:
        time.sleep(0.1)
        sources = [
            source
            for source in pulse.source_list()
            if source.card == card.index
            or source.name == "auto_null"
            or profile.name == "off"
        ]

    source_output = sources[0]
    pulse.default_set(source_output)
    for source_input in pulse.sink_input_list():
        pulse.source_input_move(source_input.index, source_output.index)

def _select_output(pulse, card, profile):
    pulse.card_profile_set(card, profile.name)

    sinks = []
    while not sinks:
        time.sleep(0.1)
        sinks = [
            sink
            for sink in pulse.sink_list()
            if sink.card == card.index
            or sink.name == "auto_null"
            or profile.name == "off"
        ]

    sink_output = sinks[0]
    pulse.default_set(sink_output)
    for sink_input in pulse.sink_input_list():
        pulse.sink_input_move(sink_input.index, sink_output.index)


def _get_bluetooth_device_info(mac):
    info = {}
    for line in _run(f"bluetoothctl info {mac}").split("\n")[1:]:
        name, _, value = line.strip().partition(": ")
        if name == "UUID":
            value = value.split("(")[0].strip()
            info.setdefault(name, []).append(value)
        else:
            info[name] = value
    return info


def _bluetooth_scan():
    try:
        _run("bluetoothctl scan on", timeout=10)
    except subprocess.TimeoutExpired:
        pass


def _get_bluetooth_items():
    items = {}
    if _is_bluetooth_on():
        for line in _run("bluetoothctl devices").split("\n"):
            if not line.strip():
                continue
            mac, _, name = line.strip()[7:].partition(" ")
            info = _get_bluetooth_device_info(mac)
            name = info.get("Name", "Unknown")
            prefix = f"ðŸŽ§ {name} / {mac} |"
            if info["Paired"] == "yes":
                connected = info["Connected"] == "yes"

                if "Audio Sink" in info["UUID"]:
                    if connected:
                        items[f"{prefix} Disconnect"] = f"bluetoothctl disconnect {mac}"
                    else:
                        items[f"{prefix} Connect"] = f"bluetoothctl connect {mac}"

                items[f"{prefix} Unpair"] = f"bluetoothctl remove {mac}"
            else:
                items[f"{prefix} Pair"] = [
                    f"bluetoothctl trust {mac}",
                    f"bluetoothctl pair {mac}",
                    f"bluetoothctl connect {mac}",
                ]
        items[" ï–®  Scan (10 seconds)"] = _bluetooth_scan
        items[" ï–®  Off"] = "bluetoothctl power off"
    else:
        items["Bluetooth | On"] = "bluetoothctl power on"

    return items

HIDDEN_PROFILES = (
    "input:analog-stereo", # We keep only the duplex
    "output:analog-stereo", # We keep only the duplex
    "pro-audio",
    "*iec958*",
    "input:mono-fallback",
)


def _get_pulseaudio_cards_profiles(pulse, mode="sink"):
    if mode == "sink":
        default_name = pulse.server_info().default_sink_name
        default_index = [
            sink.card for sink in pulse.sink_list() if sink.name == default_name
        ][0]
    elif mode == "source":
        default_name = pulse.server_info().default_source_name
        default_index = [
            source.card for source in pulse.source_list() if source.name == default_name
        ][0]
    else:
        raise RuntimeError(f"wrong mode: {mode}")
    items = {}
    cards = pulse.card_list()
    for card in reversed(cards):
        for profile in reversed(card.profile_list):
            if not profile.available:
                continue 
            if any(p for p in HIDDEN_PROFILES if fnmatch.fnmatch(profile.name, p)):
                continue
            if mode == "sink" and profile.n_sinks==0:
                continue
            if mode == "source" and profile.n_sources==0:
                continue

            print(profile)
            selected = False
            if (
                card.index == default_index
                and profile.name == card.profile_active.name
            ) or (profile.name == "off" and default_name == "auto_null"):
                selected = True
            if card.proplist["device.icon_name"].endswith("bluetooth"):
                icon = "ðŸŽ§"
            elif mode == "sink":
                icon = "ðŸ”Š"
            elif mode == "source":
                icon = "ðŸŽ¤"
            else:
                raise RuntimeError(f"wrong mode: {mode}")
            label = f"{icon} {card.proplist['device.description']} | {profile.description}"
            if selected:
                label = f"<b>{label}</b>"
            if mode == "sink":
                items[label] = functools.partial(_select_output, pulse, card, profile)
            elif mode == "source":
                items[label] = functools.partial(_select_input, pulse, card, profile)
            else:
                raise RuntimeError(f"wrong mode: {mode}")
    return items


def main(pulse):
    items = {}
    items["Audio Output"] = "pavucontrol -t 3"
    items.update(_get_pulseaudio_cards_profiles(pulse, "sink"))
    items["Audio Input"] = "pavucontrol -t 4"
    items.update(_get_pulseaudio_cards_profiles(pulse, "source"))
    items["Bluetooth"] = "blueman-manager"
    items.update(_get_bluetooth_items())

    for pos, key in enumerate(items):
        if "<b>" in key:
            break
    else:
        pos = None

    if pos is not None:
        selection = ["-selected-row", str(pos)]
    p = subprocess.Popen(
        ["rofi", "-dmenu", "-markup-rows"] + selection,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        text=True,
    )
    selected = p.communicate(input="\n".join(items.keys()))[0][:-1]
    if selected:
        callback = items.get(selected)
        if callback:
            if isinstance(callback, str):
                _run(callback)
            elif isinstance(callback, list):
                for c in callback:
                    _run(c)
            else:
                callback()
        else:
            print("Selected invalid")
    else:
        print("Nothing selected")


if __name__ == "__main__":
    with pulsectl.Pulse("sound-controller") as pulse:
        main(pulse)
